start with CompilationUnit;


CompilationUnit
        ::=	TypeDeclarations:td
        ;

TypeDeclarations
        ::= TypeDeclaration:td
		{: RESULT = td; :}
        |   TypeDeclarations:tds  TypeDeclaration:td
		{: RESULT = tds.makeSibling(td);  :}
        ;

TypeDeclaration
        ::= ClassDeclaration:rhs
		{: RESULT = rhs; :}
        ;


ClassDeclaration
        ::= Modifiers:mods CLASS:cl Identifier:id ClassBody:clb
      {: RESULT = new ClassNode(id).setModNode(mods).adoptChildren(clb); :}
	;

/*
 * Modified to only allow standard combinations of modifiers
 * public static, static public, private static, static private, 
 * public, private, static
 */
Modifiers
	::= PUBLIC
		{: RESULT = new ModNode(ModNode.PUB); :}
	|   PRIVATE
		{: RESULT = new ModNode(ModNode.PRI); :}
	|   STATIC
		{: RESULT = new ModNode(ModNode.STAT); :}
	|   ModifiersP:mds PUBLIC
		{: RESULT = mds.set(ModNode.PUB); :}
	|   ModifiersP:mds PRIVATE
		{: RESULT = mds.set(ModNode.PRI); :}
	|   ModifiersS:mds STATIC
		{: RESULT = mds.set(ModNode.STAT); :}
	;


ModifiersP
	::=STATIC
		{: RESULT = new ModNode().set(ModNode.STAT); :}
	;
	
ModifiersS
	::= PUBLIC
		{: RESULT = new ModNode().set(ModNode.PUB); :}
	|	PRIVATE
		{: RESULT = new ModNode().set(ModNode.PRI); :}
	;
	
Identifier
	::= IDENTIFIER:id
	{:RESULT = new IDNode(id); :}
	;


ClassBody
	::= LBRACE FieldDeclarations:fds RBRACE
	{: 
		//ignore first node, it's a FieldNode used to gather the rest.....
		RESULT = makeNode("Class Body").adoptChildren(fds.getChild()); 
	:}
	|   LBRACE RBRACE
	{: 
		FieldNode fn = new FieldNode("Fields");
		RESULT = makeNode("Class Body").adoptChildren(fn); //nothing to do, empty class :}
	;

FieldDeclarations
	::= FieldDeclaration:fd
	{: 
		FieldNode fn = new FieldNode("Fields");
		fn.fieldMap.get(fd.getName()).adoptChildren(fd.getChild()); 
		RESULT = fn; 
	:}
    |   FieldDeclarations:fds FieldDeclaration:fd
    {: 
    	FieldNode fn = (FieldNode) fds;
    	fn.fieldMap.get(fd.getName()).adoptChildren(fd.getChild());
    	RESULT = fn; 
    
    :}
    ;

FieldDeclaration
	::= FieldVariableDeclaration:fvd SEMICOLON
	{: RESULT = makeNode("Fields").adoptChildren(fvd); :}
	|   MethodDeclaration:rhs
	{: RESULT = makeNode("Methods").adoptChildren(rhs); :}
	|   ConstructorDeclaration:rhs
	{: RESULT = makeNode("Constructors").adoptChildren(rhs); :}
	|   StaticInitializer:si
	{: RESULT = makeNode("Statics").adoptChildren(si); :}
	|   ClassDeclaration:cd                     /* Inner classes */
	{: RESULT = makeNode("Inner Classes").adoptChildren(cd); :}
	;

TypeSpecifier
        ::= TypeName:rhs
        {: RESULT = rhs; :}
        ;

TypeName
	::= PrimitiveType:rhs
		{: RESULT = rhs; :} 
	|   QualifiedName:rhs
		{: RESULT = rhs; :}
	;

/*
 * Extra credit:  other types
 */
PrimitiveType
        ::=	BOOLEAN:tok
        {: 
        		String t = HELPER.typeMap.get(symString.symToString[tok.sym]);
        		IDNode tempNode = new IDNode(t);
        		RESULT = tempNode; 
        :}
        | 	INT:tok
        {:  
        		String t = HELPER.typeMap.get(symString.symToString[tok.sym]);
        		IDNode tempNode = new IDNode(t);
        		RESULT = tempNode; 
        :}
        | 	VOID:tok
        {: 	
        		String t = HELPER.typeMap.get(symString.symToString[tok.sym]);
        		IDNode tempNode = new IDNode(t);
        		RESULT = tempNode; 
        :}
        |	FLOAT:tok
        {:
          		String t = HELPER.typeMap.get(symString.symToString[tok.sym]);
        		IDNode tempNode = new IDNode(t);
        		RESULT = tempNode; 
        :}
        |	DOUBLE:tok
        {:
        		String t = HELPER.typeMap.get(symString.symToString[tok.sym]);
        		IDNode tempNode = new IDNode(t);
        		RESULT = tempNode; 
        :}
        ;

QualifiedName
        ::= Identifier:id
        	{:	
        		RESULT = id; 
        	:}
        |   QualifiedName:qn PERIOD Identifier:id
        	{: 
        		qn.addName(id);
        		RESULT = qn; 
        	:}
        ;

FieldVariableDeclaration
	::= Modifiers:m TypeSpecifier:t FieldVariableDeclarators:fvds
	{:
		VariableNode vn = new VariableNode(t);
		vn.setNodeType(VAL.INSTANCE_DECLARATION);
		vn.setModNode(m);
		vn.adoptChildren(fvds);
		RESULT = vn;
	:}
	;
	
FieldVariableDeclarators
	::=  FieldVariableDeclaratorName:v
	{: RESULT = v; :}
	|    FieldVariableDeclarators:fds COMMA FieldVariableDeclaratorName:v
	{: 
		RESULT = fds.makeSibling(v); 
	:}
	;
	
FieldVariableDeclaratorName ::= Identifier:in 
	{: 
		IDNode temp = new IDNode(in.toString());
		VariableNode vn = new VariableNode(temp);
		vn.setNodeType(VAL.INSTANCE);
		RESULT = vn; 
	:};
	

	
/*
 * We require modifiers, but we'll skip the package stuff.
 */
MethodDeclaration
	::= Modifiers:m TypeSpecifier:t MethodDeclarator:md     MethodBody:rhs
	{:
		VariableNode vn = new VariableNode(t);
		vn.setNodeType(VAL.METHOD_RETURN_TYPE);
		vn.setModNode(m);
		md.adoptChildren(rhs);
		vn.adoptChildren(md);
		RESULT = vn;
	:}
	;

MethodDeclarator
	::= MethodDeclaratorName:dn LPAREN ParameterList:pl RPAREN
	{:
		VariableNode vn = new VariableNode(dn);
		vn.setNodeType(VAL.METHOD_NAME);
		AbstractNode params = makeNode("PARAMS");
		params.setNodeType(VAL.METHOD_PARAMS);
		params.adoptChildren(pl);
		vn.adoptChildren(params);
		RESULT = vn;
	:}
	|   MethodDeclaratorName:dn LPAREN RPAREN
	{:
		VariableNode vn = new VariableNode(dn);
		vn.setNodeType(VAL.METHOD_NAME);
		AbstractNode params = makeNode("PARAMS");
		params.setNodeType(VAL.METHOD_PARAMS);
		vn.adoptChildren(params);
		RESULT = vn;
	:}
	;

ParameterList
	::= Parameter:rhs
	{:
		RESULT = rhs;
	:}
	|   ParameterList:spine COMMA Parameter:rhs
	{:
		RESULT = spine.makeSibling(rhs);
	:}
	;

Parameter
	::= TypeSpecifier:t DeclaratorName:dn
	{:
		VariableNode p = new VariableNode(dn);
		p.setSpecifiers(t);
		p.setNodeType(VAL.METHOD_PARAM_DECLARATION);
		RESULT = p;
	:}
	;

DeclaratorName
	::= Identifier:in
	{: RESULT = in; :}
   ;

MethodDeclaratorName
	::= Identifier:in
	{: RESULT = in; :}
   ;





MethodBody
	::= Block:rhs
	{: RESULT = rhs; :}
	;

ConstructorDeclaration
	::= Modifiers:m MethodDeclarator:md        Block:rhs
	{: 
		AbstractNode t = makeNode("V");
		VariableNode vn = (VariableNode) md;
		vn.setModNode(m);
		vn.adoptChildren(rhs);
		vn.setNodeType(VAL.CONSTRUCTOR_DECLARATOR);
		t.adoptChildren(vn);
		RESULT = t;
	:}
	;

StaticInitializer
	::= STATIC Block:rhs
	{: 
		rhs.setNodeType(VAL.STATIC_BLOCK);
		RESULT = rhs; :}
	;

/*
 * These can't be reorganized, because the order matters.
 * For example:  int i;  i = 5;  int j = i;
 */
Block
	::= LBRACE LocalVariableDeclarationsAndStatements:stmts RBRACE
	{: 
		AbstractNode an = new TemporaryNode("BLOCK");
		an.adoptChildren(stmts);
		RESULT = an;
	:}
	
	|   LBRACE RBRACE
	{:
		RESULT = new TemporaryNode("BLOCK");
	:}
	;

LocalVariableDeclarationsAndStatements
	::= LocalVariableDeclarationOrStatement:rhs
	{:	 
		 RESULT = rhs; 
	:}	
	|   LocalVariableDeclarationsAndStatements:lvds LocalVariableDeclarationOrStatement:rhs
	{:
		 lvds.makeSibling(rhs);
		 RESULT = lvds;
	:}
	;

LocalVariableDeclarationOrStatement
	::= LocalVariableDeclarationStatement:rhs
	{: 
   	 
		RESULT = rhs; 
	:}
	|   Statement:rhs
	{: 	
		RESULT = rhs; 
	:}
	;

LocalVariableDeclarationStatement
	::= LocalDeclaration:rhs SEMICOLON
	{:
		RESULT = rhs;
	:}
	|	LocalDeclaration:lhs AssignmentOperator:op AssignmentExpression:rhs SEMICOLON
	{:
			lhs.makeSibling(op);
			VariableNode vn = new VariableNode(new IDNode(lhs.getName()));
			vn.setNodeType(VAL.LOCAL);
			vn.setModNode(new ModNode(ModNode.VOID));
			op.adoptChildren(vn);
			op.adoptChildren(rhs);
			RESULT = lhs;
	:}
	|   ClassDeclaration:cd                     /* Inner classes */
	{: RESULT = cd; :}
	;


LocalDeclaration
	::= TypeSpecifier:t LocalVariableDeclarators:rhs
	{:
		VariableNode vn = new VariableNode(t);
		vn.setNodeType(VAL.LOCAL_DECLARATION_HEADING);
		vn.setModNode(new ModNode(ModNode.VOID));
		vn.adoptChildren(rhs);
		RESULT = vn;
	:}
	;
	
LocalVariableDeclarators
	::= LocalVariableDeclaratorName:v
	|   LocalVariableDeclarators:fds COMMA LocalVariableDeclaratorName:v
	;

LocalVariableDeclaratorName
	::= Identifier:in
 	;
 	
Statement
	::= EmptyStatement: es
	|   ExpressionStatement:rhs SEMICOLON
   |   SelectionStatement:rhs
   |   IterationStatement:is
	|   ReturnStatement:rs
	|   Block:rhs
	;

EmptyStatement
	::= SEMICOLON
    ;

ExpressionStatement
	::= Expression:rhs
	;
	
Expression
	::= AssignmentExpression:rhs
    ;

SelectionStatementInit   : IF LPAREN Expression RPAREN Statement:stOne SelectionStatementContinue
                         ;

SelectionStatementContinue :  ELSE Statement
                           |
                           ;
IterationStatement
	::= WHILE LPAREN Expression:ex RPAREN Statement:st
	| ForIterationStatement:fs
	;

ForIterationStatement
	::= BasicFor:bf
	;

BasicFor ::= FOR LPAREN InitFor:init RelationalExpression:ex SEMICOLON AssignmentExpression:ass RPAREN ForStatement:st
		 ;
		 
ForStatement ::= LBRACE Statement:st RBRACE
			 | SEMICOLON //treat as if just 
			 | LBRACE RBRACE //treat like semi
			 ;

InitFor ::= LocalVariableDeclarationStatement:ob
		;
		

ReturnStatement
	::= RETURN Expression:ex SEMICOLON
	|   RETURN            SEMICOLON
	;

PrimaryExpression
	::= QualifiedName:t
	|   NotJustName:rhs
	;

NotJustName
	::= SpecialName:sn
	|   AllocationExpression:ae
	|   ComplexPrimary:cp
	;

SpecialName
	::= THIS:tok
	|   NULL:tok
		|   SUPER:tok
	;

AllocationExpression
	::= NEW:tok TypeName:tn LPAREN ArgumentList:list RPAREN
	|   NEW:tok TypeName:tn LPAREN              RPAREN
	;
	
ComplexPrimary
	::= LPAREN Expression:rhs RPAREN
	|   ComplexPrimaryNoParenthesis:rhs
	;

ComplexPrimaryNoParenthesis
	::= Literal:rhs
	|   Number:rhs
	|   FieldAccess:fa
	|   MethodCall:mc
	;

FieldAccess
	::= NotJustName:njn PERIOD Identifier:id
	;

MethodCall
	::= MethodReference:rhs LPAREN ArgumentList:args RPAREN
	|   MethodReference:rhs LPAREN RPAREN
	;

MethodReference
	::= ComplexPrimaryNoParenthesis:rhs
	|   QualifiedName:rhs
	|   SpecialName:rhs
	;


ArgumentList
	::= Expression:ex
	|   ArgumentList:lhs COMMA Expression:ex
	;

PostfixExpression
	::= PrimaryExpression:rhs
   ;

AssignmentExpression
	::= ConditionalExpression:rhs
	|   UnaryExpression:lhs AssignmentOperator:op AssignmentExpression:rhs
	| UnaryExpression:lhs INCREMENT
	| UnaryExpression:lhs DECREMENT
	;

AssignmentOperator
	::= EQUALS
	|   ASS_ADD   /* There are more of these if you're interested */
	;

ConditionalExpression
	::= ConditionalOrExpression:rhs
	|   ConditionalOrExpression:left QUESTION Expression:exp COLON ConditionalExpression:right
	;

ConditionalOrExpression
	::= ConditionalAndExpression:rhs
	|   ConditionalOrExpression:left OP_LOR:op ConditionalAndExpression:right   /* short-circuit OR */
	;

ConditionalAndExpression
	::= InclusiveOrExpression:rhs
	|   ConditionalAndExpression:left OP_LAND:op InclusiveOrExpression:right   /* short-circuit AND */
	;

InclusiveOrExpression
	::= ExclusiveOrExpression:rhs
	|   InclusiveOrExpression:left PIPE:op ExclusiveOrExpression:right
	;

ExclusiveOrExpression
	::= AndExpression:rhs
	|   ExclusiveOrExpression:left HAT:op AndExpression:right
	;

AndExpression
	::= EqualityExpression:rhs
   |   AndExpression:left AND:op EqualityExpression:right
   ;

EqualityExpression
	::= RelationalExpression:rhs
   |   EqualityExpression:left OP_EQ:op RelationalExpression:right
   |   EqualityExpression:left OP_NE:op RelationalExpression:right
   ;
 
RelationalExpression
	::= ShiftExpression:rhs
   |   RelationalExpression:left OP_GT:op    ShiftExpression:rhs
	|   RelationalExpression:left OP_LT:op    ShiftExpression:rhs
	|   RelationalExpression:left OP_LE:op      ShiftExpression:rhs
	|   RelationalExpression:left OP_GE:op      ShiftExpression:rhs
	|   RelationalExpression:left INSTANCEOF:op TypeSpecifier:rhs
	;

ShiftExpression
        ::= AdditiveExpression:rhs
   ;

AdditiveExpression
	::= MultiplicativeExpression:rhs
   |   AdditiveExpression:lhs PLUSOP:op MultiplicativeExpression:rhs
	|   AdditiveExpression:lhs MINUSOP:op MultiplicativeExpression:rhs
   ;

MultiplicativeExpression
	::= CastExpression:rhs
	|   MultiplicativeExpression:lhs ASTERICK:op CastExpression:rhs
	|   MultiplicativeExpression:lhs RSLASH:op CastExpression:rhs
	|   MultiplicativeExpression:lhs PERCENT:op CastExpression:rhs	/* remainder */
	;

/*
 * Be sure to introduce an explicit cast operator
 */
CastExpression
	::= UnaryExpression:rhs						/* no cast */
   |   LPAREN PrimitiveType:s RPAREN CastExpression:lue		/* More casts coming */
	|   LPAREN Expression:exp RPAREN LogicalUnaryExpression:lue	/* Final cast */
	;

/*
 * Extra credit:  pre-increment and pre-decrement
 */
UnaryExpression
	::= LogicalUnaryExpression:rhs
	|   ArithmeticUnaryOperator:op CastExpression:exp
	;

ArithmeticUnaryOperator
	::= PLUSOP:rhs
	|   MINUSOP:rhs
	;

LogicalUnaryExpression
	::= PostfixExpression:rhs
	|   LogicalUnaryOperator:op UnaryExpression:uexp
	;

LogicalUnaryOperator
	::= BANG:tok
	|  TILDE:tok
	;

Literal
	::= LITERAL:lit
	;

Number
	::= INTNUMBER:n
	| FLOATNUMBER:n
	;

